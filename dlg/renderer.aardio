import gdip.bitmap;
import gdip.webp;
import process.command;
import win.ui;
import win.ui.hook;
import win.ui.wallpaper;
import winex;
/*DSG{{*/
var winform = win.form(text="ChromaFlux Render";right=0;bottom=0;border="none";exmode="none";max=false;min=false;mode="popup";parent=...;sysmenu=false)
winform.add(
custom={cls="custom";left=0;top=0;right=2;bottom=2;ah=1;aw=1;db=1;dl=1;dr=1;dt=1;hide=1;z=2};
plus={cls="plus";left=0;top=0;right=2;bottom=2;ah=1;aw=1;db=1;dl=1;dr=1;dt=1;foreRepeat="stretch";hide=1;z=1}
)
/*}}*/

winform.enableDpiScaling(false);//禁用缩放，避免显示异常

var is_standalone, index, screenRW/*当前屏幕工作区RECT*/;
/*初始化MPV{{*/
var mplayer;
mpvInit = function(){
	import mpvPlayer;
	mplayer = mpvPlayer(winform.custom);
	mplayer.setOption("panscan", "1.0");
	mplayer.setOption("no-osc", "");
	mplayer.setOption("aid", "no");
	mplayer.setOption("sid", "no");
	mplayer.setOption("hwdec", "auto");
	mplayer.setOption("gpu-api", "d3d11");
	mplayer.setOption("loop-file", "inf");
	mplayer.setOption("input-default-bindings", "no");
}
/*}}*/

/*加载壁纸{{*/
var filepath, mode/*显示模式*/;
loadFile = function(filePath){
	if(!io.exist(filePath,4)){
		win.msgboxErr("指定的文件不可读", "错误");
		return false;
	}
	var ext = string.lower(string.right(io.splitpath(filePath).ext, -2));
	select(ext){
		case "mp4", "mkv", "webm", "mov", "flv", "avi" {
			if(!mode) mode = "v";
			if(!mplayer[["context"]])
				mpvInit();
			mplayer.loadFile(filePath);
			mplayer.play();
			winform.custom.show(true);

			if(mode === "p"){
				winform.plus.show(false);
				var old = winform.plus.foreground;
				winform.plus.setForeground(0xFFFFFFFF);
				if(gdip.bitmap.is(old)) old.dispose();
				mode = "v";
			}
		}
		case "png", "jpg", "jpeg", "bmp", "gif", "webp" {
			if(!mode) mode = "p";
			var old = winform.plus.setForeground(filePath,false);
			if(gdip.bitmap.is(old)) old.dispose();
			winform.plus.show(true);

			if(mode === "v"){
				winform.custom.show(false);
				mplayer.loadFile("\res\blank.png");
				mode = "p";
			}
		}
		else {
			win.msgboxErr("不支持的文件类型："+ext, "错误");
			return false;
		}
	}
	return true;
}
/*}}*/

//调试用，发布时不会编译
if(_STUDIO_INVOKED){
	index = "0";
	filepath = "/test.mp4";
	is_standalone = false;
}

index = tonumber(index : _ARGV.display);
if(!math.isInteger(index) || index < 0)
	return win.msgboxErr("未指定有效的启动参数", "错误");
filepath := _ARGV.filepath;
if(_ARGV.standalone)
	is_standalone = true;

process.command.join("ChromaFlux");
var cmd = process.command();
if(is_standalone){ //独立运行，不响应守护进程
	if(filepath && !loadFile(filepath))
		return;
	var workIndex; //当前实际显示的屏幕
	import multiMonitors;
	import win.timer;
	var mTimer = win.timer(winform, 3000);
	mTimer.onTimer = function(){
		multiMonitors.refresh();
		if(index < multiMonitors.getNum())
			workIndex = index;
		else{
			if(workIndex != 0)
				win.msgboxTimeout("指定的屏幕未连接，程序将临时切换到主屏幕显示", "提示", 5000);
			workIndex = 0;
		}
		winform.setPos(multiMonitors.getRect(workIndex).xywh());
		screenRW = multiMonitors.getRect(workIndex, true);
	}
	mTimer.enable();
	mTimer.onTimer();
	cmd.move = function(id, target){
		if(id != index || id == target)
			return;
		target = tonumber(target);
		if(!math.isInteger(target) || target < 0)
			return;
		index = target;
		workIndex = index;
		mTimer.onTimer();
	}
	cmd.reload = function(id, path){
		if(id == index && loadFile(path))
			filepath = path;
	}
	cmd.exit = function(id){
		if(id == index)
			winform.close();
	}
}
else{ //由守护进程控制
	cmd.redraw = function(scrInfo){
		var rM = scrInfo[index].rM;
		winform.setPos(rM.left, rM.top, rM.right - rM.left, rM.bottom - rM.top);
		screenRW = scrInfo[index].rW;
	}
	cmd.currentFile = function(id){
		if(id !== index)
			return;
		return #filepath ? filepath : "";
	}
	cmd.loadFile = function(id, path){
		if(id === index && loadFile(path))
			filepath = path;
	}
	cmd.isAlive = function(id){
		if(id === index)
			return true;
	}
	cmd.destroy = function(tab){
		if(tab[index])
			winform.close();
	}
}

/*动态壁纸自动暂停{{*/
var checkCovered = function(){
	var isCovered = false;
	var rc;
	winex.enumTop(function(hwnd){
		if(!winex.isVisible(hwnd) || win.isIconic(hwnd)) return; //忽略不可见和最小化的窗口
		var cls = win.getClass(hwnd);
		if(cls == "WorkerW") return false; //遇到底层WorkerW则停止枚举
		rc = win.getRect(hwnd, true);
		if(rc.left <= screenRW.left && rc.top <= screenRW.top && rc.right >= screenRW.right && rc.bottom >= screenRW.bottom){
			isCovered = true; //窗口遮挡桌面自动暂停，同时停止枚举
			return false;
		}
	});
	mplayer.pause(isCovered);
}
var timeoutID;
var callback = function(hHook, event, hwnd, idObject, idChild, dwThread, dwTime){
	if(idObject != 0/*_OBJID_WINDOW*/) return;
	if(mode !== "v" || !screenRW) return;
	select(event){
		case 0x0020/*EVENT_SYSTEM_DESKTOPSWITCH*/{
			var isDefault = false;
			var hInputDesktop = ::User32.OpenInputDesktop(0, false, 0x80000000/*_GENERIC_READ*/);
			if(hInputDesktop){
				var name = raw.buffer(32);
				if(::User32.GetUserObjectInformationA(hInputDesktop, 2/*_UOI_NAME*/, name, #name, 0) && string.cmp(name,"Default") == 0)
					isDefault = true;
				::User32.CloseDesktop(hInputDesktop);
			}
			mplayer.pause(!isDefault); //非默认桌面自动暂停
		}
		case 0x0003/*_EVENT_SYSTEM_FOREGROUND*/{
			checkCovered(); //精确响应，不防抖
		}
		case 0x800B/*_EVENT_OBJECT_LOCATIONCHANGE*/{ //该事件触发频率极高，窗口移动或改变大小都会触发，因此要防抖
			if(hwnd != win.getForeground() || hwnd == winform.hwnd) return;
			win.clearTimeout(timeoutID);
			timeoutID = win.setTimeout(function(){
				timeoutID = null;
				checkCovered();
			}, 500);
		}
	}
}
var hook_system = win.ui.hook(callback, 0x0003/*_EVENT_SYSTEM_FOREGROUND*/, 0x0020/*EVENT_SYSTEM_DESKTOPSWITCH*/);
var hook_object = win.ui.hook(callback, 0x800B/*_EVENT_OBJECT_LOCATIONCHANGE*/, 0x800B/*_EVENT_OBJECT_LOCATIONCHANGE*/);
/*}}*/

winform.onDestroy = function(){
	mode = null;
	win.ui.wallpaper.restore(winform);
	hook_system.close();
	hook_object.close();
}

var ok, err = win.ui.wallpaper.embed(winform);
if(!ok)
	return win.msgboxErr(err:"未知错误", "错误");

winform.show();
win.loopMessage();